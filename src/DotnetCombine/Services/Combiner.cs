using DotnetCombine.Model;
using DotnetCombine.Options;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DotnetCombine.Services
{

    public class Combiner : OutputFileManager
    {
        public override string OutputExtension { get { return CSharpOutputExtension; } }

        private CombineOptions _options;
        public override CombineOptions options { get { return _options; } }


        public Combiner(CombineOptions options)
            : base(options)
        {
            _options = options;
        }

        public Task<int> Run()
        {
            Func<Task> actions = async () =>
            {
                var filePaths = FindFilesToInclude();
                var parsedFiles = await ParseFiles(filePaths);
                await AggregateFiles(parsedFiles);
            };
            return base.Run(actions);
        }

        protected override IList<string> FindFilesToInclude()
        {
            if (File.Exists(options.Input))
            {
                return new List<string> { options.Input };
            }

            var filesToExclude = options.ExcludedItems
                .Where(item => !Path.EndsInDirectorySeparator(item))
                .ToList();

            filesToExclude.Add(Path.GetFileName(outputFilePath));

            var dirsToExclude = options.ExcludedItems
                .Except(filesToExclude)
                .Select(dir => Path.DirectorySeparatorChar + dir.ReplaceEndingDirectorySeparatorWithProperEndingDirectorySeparator());

            var result = Directory.GetFiles(options.Input, $"*{OutputExtension}", SearchOption.AllDirectories)
                .Where(filePath =>
                    dirsToExclude?.Any(exclusion =>
                        $"{Path.GetDirectoryName(filePath)}{Path.DirectorySeparatorChar}"?.Contains(exclusion, StringComparison.OrdinalIgnoreCase) == true)
                        == false
                    && filesToExclude?.Any(exclusion => string
                    .Equals(Path.GetFileName(filePath), exclusion, StringComparison.OrdinalIgnoreCase))
                        == false
                && !UniqueIdGenerator.GeneratedFileNameRegex.IsMatch(Path.GetFileName(filePath)));

            if (options.PrefixWithParentFolder)
            {
                // exclure les fichiers qui commence par le nom du dossier qui les contients + "_"
                // cas de dossiers dans des dossiers
                result = result.Where(filePath => !Path.GetFileName(filePath)
                        .StartsWith(new DirectoryInfo($"{Path.GetDirectoryName(filePath)}".ReplaceEndingDirectorySeparatorWithProperEndingDirectorySeparator()).Name + "_"));
            }

            return result.OrderBy(s => s)
                        .ToList();
        }

        private async Task<ICollection<SourceFile>> ParseFiles(IEnumerable<string> filePaths)
        {
            var tasks = filePaths.Select(async filePath =>
            {
                var parsedFile = new SourceFile(filePath);
                await parsedFile.Parse(options);
                return parsedFile;
            });
            return (await Task.WhenAll(tasks)).ToList();
        }

        private async Task AggregateFiles(ICollection<SourceFile> parsedFiles)
        {
            var includeSection = string.Concat(parsedFiles.SelectMany(p => p.Usings).Distinct().OrderBy(_ => _));

            var codeSection = new StringBuilder();

            var orderedFiles = parsedFiles.OrderBy(file => file.Namespace?.Length).ToList();     // Top level statements first

            for (int i = 0; i < parsedFiles.Count; ++i)
            {
                var parsedFile = orderedFiles[i];

                if (options.Verbose)
                {
                    Console.WriteLine($"\t* [{i + 1}/{orderedFiles.Count}] Aggregating {parsedFile.Filepath}");
                }

                codeSection.Append(Environment.NewLine);
                codeSection.AppendJoin(Environment.NewLine, parsedFile.Code);
                codeSection.AppendJoin(Environment.NewLine, parsedFile.EndOfFile);
                codeSection.Append(Environment.NewLine);
            }

            using var fs = new FileStream(outputFilePath, options.OverWrite ? FileMode.Create : FileMode.CreateNew);
            using var sw = new StreamWriter(fs);

#if DEBUG
            // keep in debug because is used on test "OverWrite_CreatesANewFile"
            await sw.WriteLineAsync($"// File generated by dotnet-combine at {DateTime.Now.ToLocalTime().ToString(UniqueIdGenerator.DateFormat)}{Environment.NewLine}");
#endif
            await sw.WriteAsync(includeSection);
            //await sw.WriteAsync(Environment.NewLine);
            //await sw.WriteAsync(Environment.NewLine);
            await sw.WriteAsync(codeSection);

        }
    }
}